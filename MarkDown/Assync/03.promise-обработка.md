## Обработка ошибок

Цепочки промисов отлично подходят для перехвата ошибок. Если промис завершается с ошибкой, то управление переходит в ближайший обработчик ошибок. На практике это очень удобно.

Например, в примере ниже для `fetch` указана неправильная ссылка (сайт не существует), и `.catch` перехватывает ошибку:

```javascript
fetch('https://no-such-server.blabla')
    .then (response => response.json())
    .catch (err => console.log(err)) // TypeError: "NetworkError when attempting to fetch resource."
```

Как видно, `.catch` не обязательно должен быть сразу после ошибки, он может быть далее, после одного или даже нескольких `.then`

Или может быть с сервером всё в порядке, но в ответе мы получим некорректный JSON. Самый лёгкий пусть перехватить все ошибки - это добавить `.catch` в конце цепочки: 

```javascript
fetch('/article/promise-chaining/user.json')
    .then (response => response.json())
    .then (user => fetch(`https://api.github.com/users/${user.name}`))
    .then (response => response.json())
    .then (githubUser => new Promise ( (resolve, reject) => {
        let img = document.createElement('img')
        img.src = githubUser.avatar_url
        img.className = "promise-avatar-example"
        document.body.append(img)

        setTimeout( () => {
            img.remove()
            resolve(githubUser)
        }, 3000)
    }))
    .catch (error => console.log(error.message))
```

Если всё в порядке, то такой `.catch` вообще не выполнится. Но если любой из промисов будет отклонён (проблемы с сетью или некорректная json-строка или что угодно), то ошибка будет перехвачена.
***

## Неявный try...catch

Вокруг функции промиса из обработчиков находится "невидимый `try..catch`. Если происходит исключение, то оно перехватывается и промис считается отклонённым с этой ошибкой.

```javascript
new Promise ( (resolve, reject) => {
    throw new Error("Ошибочка")
}).catch (console.log) // Ошибочка
```

Тоже самое, что код это: 

```javascript
new Promise ( (resolve, reject) => {
    reject (new Error("Ошибочка"))
}).catch (console.log) // ошибочка
```

"Невидимый `try..catch`" вокруг промиса автоматически перехватывает ошибку и превращает её в отклонённый промис.

Это работает не только в функции промиса, но и в обработчиках. Если мы бросим ошибку (`throw`) из обработчика (`.then`), то промис будет считаться отклонённым и управление перейдет к ближайшему обработчику ошибок.

```javascript
new Promise ( (resolve, reject) => {
    resolve("ok")
}).then ( (result) => {
    throw new Error("Ошибка") 
}).catch (console.log) // Ошибка
```

Это происходит для всех ошибок, не только для тех, которые вызваны оператором `throw`. Например, програмная ошибка:

```javascript
new Promise ( (resolve, reject) => {
    resolve("ok")
}).then ( (result) => {
    blabla() // нет такой функции
}).catch (console.log) // blabla is not defined
```
Финальный `.catch` перехватывает как промисы, в которых вызван `reject`, так и случайные ошибки в обработчиках.
***

## Пробрасывание ошибок

`.catch` ведёт себя как `try..catch`. Можно иметь несколько обработчиков `.then`, столько, сколько мы хотим, и затем использовать один `.catch` в конце, чтобы перехватить ошибки из всех обработчиков.

В обычном `try..catch` можно проанализировать ошибку и повторно пробросить дальше, если не можем её обработать. Тоже самое возможно для промисов.

Если мы пробросим (`throw`) ошибку внутри блока (`.catch`), то управление перейдет к следующему ближайшему обработчику ошибок. А если мы обработаем ошибку и завершим работу обработчика нормально, то продолжит работу ближайший успешный обработчик `.then`.

В примере ниже `.catch` успешно обрабатывает ошибку:

```javascript
new Promise ( (resolve, reject) => {
    throw new Error("Ошибка")
}).catch (function (error) {
    console.log("Ошибка обработана, продолжить работу")
}).then ( () => console.log("Управление перейдет в следующий then"))
```
Здесь блок `.catch` завершается нормально. По этому вызывается следующий успешный обработчик.

В примере ниже мы видим другую ситуацию с блоком `.catch`. Обработчик `(*)` перехватывает ошибку и не может обработать её (например, он знает как обработать только `URIError`), по этому ошибка пробрасывается далее: 

```javascript
new Promise ( (resolve, reject) => {
    throw new Error("Ошибочка")

}).catch (function (error) { // (*)

    if (error instanceof URIError) {
        // обрабатываем ошибку
    }
    else {
        console.log("Не могу обработать ошибку")
    }

    throw error // пробрасывает эту или другую ошибку в следующий catch

}).then (function () {
    // не выполнится
}).catch (error => { // (**)

    console.log(`Неизвестная ошибка ${error}`)
    // ничего не возвращаем => выполнение продолжается в нормальном режиме
})
```

Управление переходит от первого блока `.catch` `(*)` к следующему `(**)` вниз по цепочке.
***

## Необработанные ошибки

Что произойдет, если ошибка не будет обработана? Например, можем просто забыть добавить `.catch` в конец цепочки, как тут: 

```javascript
new Promise (function () {
    noSuchFunction() // ошибка, нет такой функции
})
    .then ( () => {
        // обработчики .then, один или более
        // без .catch в самом конце!
    })
```

В случае ошибки выполнение должно перейти к ближайшему обработчику ошибок. Но в примере выше нет никакого обработчика. По этому ошибка как бы застревает, её некому обработать.

На практике, как и при обычных необработанных ошибках в коде это означает, что что-то пошло сильно не так.

Что просходит, когда обычная ошибка не перехвачена `try..catch`? Скрипт умирает с сообщением в консоли. Похожее происходит в случае необработанной ошибки промиса.

В браузере можно поймать такие ошибки, используя событие `unhandledrejection`:

```javascript
window.addEventListener("unhandledrejection", function (event) {
    // объект события имеет два специальных свойства:
    console.log(event.promise) // [object Promise] - промис, который сгерерировал ошибку
    console.log(event.reason) // Error: Ошибка! - объект ошибки, которая не была обработана
})

new Promise (function () {
    throw new Error("Ошибка!")
}) // нет обработчика ошибок
```

Это событие является частью стандарта HTML.

Если происходит ошибка и отсутстует её обработчик, то генерируется событие `unhandledrejection` и соответствующий объект `event` содержит информацию об ошибке.

Обычно такие ошибки неустранимы, по этому лучше всего - информировать пользователя о проблеме и, возможно, отправить информацию об ошибке на сервер.