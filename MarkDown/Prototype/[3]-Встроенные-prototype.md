- [Встроенные методы](#встроенные-методы)
- [Примитивы](#примитивы)
- [Изменение встроенных прототипов](#изменение-встроенных-прототипов)
  - [Важно:](#важно)
- [Заимствование методов у прототипов](#заимствование-методов-у-прототипов)

## Встроенные методы

Встроенные объекты, такие как `Array`, `Date`, `Function` и другие, хранят свои методы в прототипах.

При создании массива `[1, 2, 3]` внутренне используется конструктор массива `Array`. По этому прототипом массива становится `Array.prototype`, предоставляя ему свои методы. 

**В спесификации, наверху иерархии встроенных прототипов находится `Object.prototype.`**

![qq](\img\Object.prototype-and-All.jpg)

Проверка прототипов согласно спецификации: 

```javascript
const arr = [1, 2, 3]

// наследует от Array.prototype
console.log(arr.__proto__. === Array.prototype) // true

// наследует от Object.prototype
console.log( arr.__proto__.__proto__ === Object.prototype ) // true

// null - вершина иерархии
console.log( arr.__proto__.__proto__.__proto__ ) // null
```

Некоторые методы в прототипах могут пересекаться, например, у `Array.prototype` есть свой метод `toString`, который выводит элементы массива через запятую: 

```javascript
const arr = [1, 2, 3]

alert(arr) // 1,2,3 - результат Array.prototype.toString
```

У `Object.prototype` есть свой метод `toString`, **но, т.к. `Array.prototype` ближе в цепочке прототипов, то метод берётся именно из него.**
***

## Примитивы

Самое сложное происходит со строками, числами и булевыми значениями.

Это не объекты и если попытаться получить доступ к их свойствам, то будет создан временный объект-обёртка с использованием конструкторов `String`, `Number` и `Boolean`, который предоставит методы и после этого изчезнет.

Методы этих объектов так же находятся в прототипах, доступных как `String.prototype`, `Number.prototype` и `Boolean.prototype`.

**Значения `null` и `undefined` не имеют объектов-обёрток.**
***

## Изменение встроенных прототипов

Встроенные прототипы можно изменять. Если добавить метод к `String.prototype` - метод становится доступен для всех строк:

```javascript
String.prototype.kravich = function () {
    console.log(`${this} Kravich`) // this - то, что стоит перед точкой
}

"Vlad".kravich() // Vlad Kravich
```


### Важно: 

Прототипы глобальны, по этому могут возникнуть конфликты. Если две бибилиотеки добавляют метод `String.prototype.kravich` - то одна из них перезапишет метод другой библиотекой.
***

**В современном программировании есть только один случай, в котором одобряется изменение встроенных прототипов. Это создание полифилов.**

Полифил - это термин, означающий эмуляцию метода, который существует в спецификации JavaScript, но ещё не поддерживаются текущим движком JavaScript.

Пример добавления собственного метода в `prototype` с полифилом: 

```javascript
if (!String.prototype.kravich) { // если нет такого метода
    
    String.prototype.kravich = function () { // создаётся метод в прототипе строк
        return `${this} Kravich`
    }
}

"Vlad".kravich() // Vlad Kravich
```
***

## Заимствование методов у прототипов

Если создать объект, который похож на массив (псевдомассив), то можно скопировать некоторые методы из `Array.prototype` в этот объект: 

```javascript
const obj = {
    0: "Vlad",
    1: "Kravich",
    length: 2.
}

obj.join = Array.prototype.join // взял метод join из Array

console.log(obj.join(', ')) // Vlad, Kravich

obj // Object { 0: "Vlad", 1: "Kravich", length: 2, join: join() }

// Т.е. самому объекту встраивается метод из прототипа массивов
```