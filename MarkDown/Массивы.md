## Array.isArray
Обычно тип данных определяется оператором `typeof`, но с массивом это не работает

Пример:

```javascript
let arr = [1,2,3]
console.log(typeof(arr))
// вернет object
```

```javascript
console.log(Array.isArray(arr)) 
// true, такой массив есть
```
***
## Array.from
Этот метод создает массив из переданных переменных

```javascript
Array.from(1,2,3)
```

***
## Array.map
Принимает функцию параметром. Возвращает новый массив и исходный массив при этом не изменяет.

Переданая функция параметром имеет три параметра:
1. элемент массива *обязательный параметр
2. индекс элемента *необязательный
3. сам исходный массив.

Эта функция будет вызвана для каждого элемента исходного массива.

Пример с умножением на два:
```javascript
let arr = [1,2,3]
let newArr = arr.map(function(elem){
    return elem * 2
}) 
newArr // вызов нового массива и будет [2,4,6]
```

Аналог в функции 

```javascript
let arr = [10,2,3]
// callback (функция), в котором мы делаем какие-то действия с элементом массива
function umnojenie (elem) { 
    return elem * 2
}
// сам метод map под капотом
function mapa (massiv, f) { 
    let arrTwo = []
    for (let i = 0; i < massiv.length; i++) {
        arrTwo[i] = f(massiv[i]) // вызов функции (запишется в новый масссив измененный элемент старого массива)
    }
    return arrTwo
}
mapa(arr, two)
```
***

## Array.filter
Принимает те же самые параметры. Формирует новый массив из тех элементов старого массива, которые прошли проверку и вернули `true`

```javascript
let arr = [1,-5,2,-7,0]
let newArr = arr.filter(function(elem){
    if (elem % 2 == 0) {
        return true
    }
})
console.log(newArr) // [2,0]
``` 

Аналог в функции

```javascript
let arr = [10,5,3,6,2]
// всё тоже самое как в map
function chetniy (elem) {
    if (elem % 2 == 0) {
        return true
    }
}

function filter (massiv, f) {
    let arrTwo = []
    for (let i = 0; i < massiv.length; i++) {
        if (f(massiv[i]) == true) {
            arrTwo[arrTwo.length] = massiv[i] //запишется тот элемент, который прошел проверку
        }
    }
    return arrTwo
}
filter(arr, three)
```
***
## Array.every
Принимает те же самые параметры. Если `callback` функция вернёт `true` для каждого из элементов массива, то `arr.every` вернёт `true`, иначе `false`.

```javascript 
let arr = [1,-5,2,-7,0]
let newArr = arr.every(function(elem){
    if (elem > -Infinity) {
        return true
    }
})
console.log(newArr) // true
```

Аналог в функции

```javascript
function positive (elem) {
    if (elem > 0) {
        return true
    }
    else {
        return false
    }
}

function everyy(massiv, funct) {
    let isOk = true
    for (let i = 0; i < massiv.length; i++) {
        if (funct(massiv[i]) == false) {
            isOk = false
            break
        }
    }
    return isOk
}
console.log(everyy([-10, 10, 5], positive)) // false
console.log(everyy([10, 52, 4], positive)) // true, все элементы массива прошли проверку
```
***
## Array.some
Как предыдущий, только проверку должны пройти не все элементы, а хотя бы один.

```javascript
let arr = [1,-5,2,-7,0]
let newArr = arr.some(function(elem){
    if (elem > 0) {
        return true
    }
})
console.log(newArr) // true ибо есть некоторые элементы, которые больше нуля
```

Аналог в функции

```javascript
function negative (elem) {
    if (elem < 0) {
        return true
    }
    else {
        return false
    }
}

function somme (massiv, funct) {
    let isOk = false
    for (let i = 0; i < massiv.length; i++) {
        if (funct(massiv[i]) == true) {
            isOk = true
            break
        }
    }
    return isOk
}
console.log(somme(([1,2,3,-1]), negative)) // true, хотя бы один элемент прошел проверку
console.log(somme(([1,2,3]), negative)) // false, ни один элемент не прошел проверку
```
***