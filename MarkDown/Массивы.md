## Array.isArray
Обычно тип данных определяется оператором `typeof`, но с массивом это не работает

Пример:

```javascript
let arr = [1,2,3]
console.log(typeof(arr))
// вернет object
```

```javascript
console.log(Array.isArray(arr)) 
// true, такой массив есть
```
***
## Array.from
Этот метод создает массив из переданных переменных

```javascript
Array.from(1,2,3)
```

***
## Array.map
Принимает функцию параметром. Возвращает новый массив и исходный массив при этом не изменяет.

Переданая функция параметром имеет три параметра:
1. элемент массива *обязательный параметр
2. индекс элемента *необязательный
3. сам исходный массив.

Эта функция будет вызвана для каждого элемента исходного массива.

Пример с умножением на два:
```javascript
let arr = [1,2,3]
let newArr = arr.map(function(elem){
    return elem * 2
}) 
newArr // вызов нового массива и будет [2,4,6]
```
***

## Array.filter
Принимает те же самые параметры. Формирует новый массив из тех элементов старого массива, которые прошли проверку и вернули `true`

```javascript
let arr = [1,-5,2,-7,0]
let newArr = arr.filter(function(elem){
    if (elem % 2 == 0) {
        return true
    }
})
console.log(newArr) // [2,0]
```
***
## Array.every
Принимает те же самые параметры. Если `callback` функция вернёт `true` для каждого из элементов массива, то `arr.every` вернёт `true`, иначе `false`.

```javascript 
let arr = [1,-5,2,-7,0]
let newArr = arr.every(function(elem){
    if (elem > -Infinity) {
        return true
    }
})
console.log(newArr) // true
```
***
## Array.some
Как предыдущий, только проверку должны пройти не все элементы, а хотя бы один.

```javascript
let arr = [1,-5,2,-7,0]
let newArr = arr.some(function(elem){
    if (elem > 0) {
        return true
    }
})
console.log(newArr) // true ибо есть некоторые элементы, которые больше нуля
```
***