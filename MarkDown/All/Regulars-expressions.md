# Самое важное из регулярных выражений

Регулярное выражение состоит из шаблона (строчки) и флагов (для заданных условий поиска).

Есть два способа создания регулярного выражения:

1. Длинный:
```javascript
let regexp = new RegExp("кравич", "флаг")
```

2. Короткий:
```javascript
let regexp = /кравич/ // без флагов
let regexp = /кравич/i // с флагом любого регистра
```

В обоих случаях регулярное выражение являются объектом встроенного класса `RegExp`.

**Разница между двумя способами в том, что слеши `/.../` не допускают никаких вставок переменных типа `${best}`. Слеши статичны и менять их нельзя.**

```javascript
let tag = prompt("Какой тег вы хотите найти?", "h2")

let regexp = new RegExp(`<${tag}>`) // то же, что /<h2>/  при ответе "h2" на prompt выше
```
***

## Флаги

* `i`- неважен регистр (а или А).

* `g` - с этим флагом поиск ищет все совпадения, **без него - лишь первое**.
* `m` - многострочный режим.
* `s` - включает режим «dotall», при котором точка `.` может соответствовать символу перевода строки `\n`.
* `u` - включает полную поддержку юникода. Флаг разрешает корректную обработку суррогатных пар. 
* `y` - режим поиска на конкретной позиции в тексте.
***
## Символьные классы

* `\d` – цифры (от `0` до `9`).

* `\D` – всё, кроме цифр.
* `\s` – пробельные символы, табы, новые строки.
* `\S` – все, кроме пробелов и прочего `\s`.
* `\w` – латиница, цифры, подчёркивание `_`.
* `\W` – все, кроме букв и прочего `\w`.
* `.` – любой символ, если с флагом регулярного выражения `s`, в противном случае любой символ, кроме перевода строки `\n`.
***

## Работа с текстом (основное)
* `^` - поиск в самом начале строки.

* `$` - поиск в самом конце строки.
* `\b \b` - граница слова.
* `символ?` - исключение (может быть такой символ).
* `|` - или.
* `[ABC]` - один из символов в квадратных скобках.
***

## Диапазоны
* `[a-z]` - искать символ от а до z.
* `[0-9]` - искать число от 0 до 9.
***

## Квантификаторы
* `+` - означает один или более.
* `?` - означает ноль или один.
* `*` - означает ноль или более.
***
# Методы и прочее

## Поиск: str.match

Метод `str.match(regexp)` для строки `str` возвращает совпадения с регулярным выражением `regexp`.

Есть три режима работы:

1. Установленный флаг `g` вернёт массив ВСЕХ совпадений:

```javascript
let str = "Vlad Kravich Играл в самп 5 лет и играЛ в л2 ещё 5 лет"
str.match(/играл/gi) // Array [ "Играл", "играЛ" ]
```

2. Без флага `g` -  вернёт только первое совпадение в виде массива, в котором по индексу `0` находится совпадение и есть свойства доп. инфы о нём:

```javascript
let str = "Vlad Kravich Играл в самп 5 лет и играЛ в л2 ещё 5 лет"

const result = str.match(/играл/i) 
result // Array [ "Играл" ]
result.index // 13
result.input // вся строка str
```

3. Если совпадений нет - то вне зависимости от наличия флага `g` вернёт `null`:

```javascript
let matches = "Kravich".match("Defo") || [] // чтобы был массив

if (!matches.length) console.log("нет совпадений")
```
*** 

## Замена: str.replace

Метод `str.replace(regexp, replacement)` заменяет совпадения с `regexp` в строке `str` на `replacement` (все, если есть флаг `g`, иначе только первое):

```javascript
console.log("Vlad Kravich, None Kravich, none Kravich".replace(/none/i, "Max"))
// заменяет ПЕРВОЕ none на Max
// Vlad Kravich, Max Kravich, none Kravich


console.log("None Kravich, none Kravich".replace(/none/ig, "Max"))
// флаг ig заменяет ВСЕ строки none в строке на Max
// Max Kravich, Max Kravich
```

В строке замены `replacement` можно использовать специальные комбинации символов для вставки фрагментов совпадения:

* **$&** - вставляет всё найденное совпадение.
* **$** - вставляет часть строки до совпадения.
* **$'** - вставляет часть строки после совпадения.
* **$n** - если `n` это 1-2 значное число, вставляет содержимое `n-й` скобочной группы регулярного выражения.
* **$<name>** - вставляет содержимое скобочной группы с именем `name`.
* **$$** - вставляет символ `$`.

Пример для первых трёх комбинаций: 

```javascript
// $& - вставляет текст после найденного совпадения
console.log("Я играл".replace(/играл/i, "$& в SAMP")) // Я играл в SAMP


// $` - вставляет часть строки до совпадения и удаляет это совпадение
console.log("Я в SAMP".replace(/я/i, "$` Был админом")) // Был админом в SAMP


// $' - вставляет часть строки после совпадения
console.log("Я в SAMP".replace(/в/i, "$' Был админом")) // Я SAMP Был админом SAMP
```
*** 

## Проверка: regexp.test

Метод `regexp.test(str)` проверяет, есть ли хоть одно совпадение, если да, то возвращает `true`, иначе `false`:

```javascript
let str = "Я Был крутым гладом"
let regexp = /был/i

regexp.test(str) // true
```
*** 

# Символьные классы
Пример использования, вычисление номера телефона по его полной форме:

```javascript
let str = "+38(066)-590-37-93"
str.replace(/\D/g, "")  // "380665903793" 
// удалить все нечисловые 
```

Также можно искать строку, после которой могут быть числа без разрыва:

```javascript
let str = "Есть ли Kravich13?"
let regexp = /kravich\d\d/i // после kravich будут две цифры

str.match(regexp) // Array [ "Kravich13" ]
```
***

# Начало и конец строки

**Эти два спецсимвола `^ $` ищут только в начале/конце строки, никакие точки не учитываются.**

Два примера: 

```javascript
// Начало
let str = "Заработаю 13 миллионов долларов"
let regexp = /^заработаю/i 

// Ищет только в самом начале строки
console.log(str.match(regexp)) // Array [ "Заработаю" ]



// Конец
let str = "Заработаю 13 миллионов долларов"
let regexp = /долларов$/i 

// Ищет только в самом конце строки
console.log(str.match(regexp)) // Array [ "долларов" ]
```
***

## Проверка на полное совпадение

Эти два "якоря" часто используются для проверки, совпадает ли строка с шаблоном полностью. 

Пример с точной проверкой строки, является ли она временем в формате `00:00`, т.е. две цифры, : и две цифры: 

```javascript
let str1 = "09:41"
let str2 = "9:41"

// в начале строки две цифры разделенные : и две цифры в конце
let regexp = /^\d{2}:\d{2}$/

console.log(regexp.test(str1)) // true - всё верно
console.log(regexp.test(str2)) // false
```
***

## Многострочный режим ^ и $ 

Многострочный режим включается флагом `m` - многострочный режим.

Этот флаг влияет также на поведение якорей, которые будут искать начало/конец строки в каждой строке текста.

Пример с началом строки:

```javascript
let str = `1е место: Макс
2е место: Влад
3е место: Кравич`

// найти все совпадения во всех строках
let regexp = /^\d/gm

console.log(str.match(regexp)) // Array(3) [ "1", "2", "3" ]
```

**Абсолютно тоже самое применимо и к концу строки**.
*** 

# Граница слова \b

Граница слова `\b` - проверка как `^` и `$`.

Когда движок JS видит `\b`, он проверяет, что позиция в строке является границей слова.

```javascript
// Array [ "Kravich" ], Kravich является словом
console.log( "Привет, Kravich".match(/\bKravich\b/) ) 

// null, Kravich не раздельное слово
console.log( "Привет, VladKravich".match(/\bKravich\b/) ) 
```

`!` не является символом слова, поэтому поиск по `Kravich!` будет `null`:

```javascript
// null
console.log( "Привет, Kravich!".match(/\bKravich!\b/) ) 
```

Можно использовать с цифрами: 

```javascript
// Array [ "13", "33" ]
console.log( "1 13 130 33".match(/\b\d{2}\b/g) ) 
```

**Граница слова `\b` не работает для алфавитов, не основанных на латинице.**
***

# Эранирование, спец. символы

Экранирование - это трансформация спец. символа в обычный символ. Точка (поиск всех) в самую обычную точку в конце предложения и т.д..

Чтобы использовать спец. символ как обычный - нужно перед ним поставить обратный слеш `\`.

Пример с экранированием точки: 

```javascript
// Array [ "5.1" ]
console.log( "Глава 5.1".match(/\d\.\d/) ) 


// null, ищет обычную точку
console.log( "Глава 511".match(/\d\.\d/) ) 
```

Тоже самое применимо ко всем остальным символам: `[ \ ^ $ . | ? * + ( )`.

**Примеры использования в файле `Экранирование.js`.**
***

## new RegExp

Если создать регулярное выражение с помощью `new RegExp`, то не нужно учитывать `/`, но нужно другое экранирование.

Например, такой поиск не работает:

```javascript
let regexp = new RegExp("\d\.\d")

console.log( "Глава 5.1".match(regexp) ) // null
```

Обычные строки имеют свои специальные символы, такие как `\n`, и для экранирования используется обратная косая черта. Поэтому, символы обратной косой черты съедаются строкой. 

Вот как воспринимается строка `\d\.\d`:

```javascript
console.log("\d\.\d") // d.d
```

Строковые кавычки «съедают» символы обратной косой черты для себя, например:

* `\n` – становится символом перевода строки,
* `\u1234` – становится символом Юникода с указанным номером,
* …А когда нет особого значения: как например для `\d` или `\z`, обратная косая черта просто удаляется.


Чтобы исправить удаление косой черты, нужно удвоить обратную косую черту, потому что строковые кавычки превращают `\\` в `\`:

```javascript
let regStr = "\\d\\.\\d"

let regexp = new RegExp(regStr)

// Array [ "5.1" ]
console.log( "Глава 5.1".match(regexp) )
```
***

# Наборы и диапазоны [...]

## Наборы

* `[abc]` - означает искать любой из набора символов в `[]`: 

```javascript
// Array [ "Vlad", "Glad" ]
console.log( "Vlad Glad".match(/[vg]lad/gi) )
```

Набор символов может соответствовать лишь одному символу, наглядный пример: 

```javascript
// null - подойдет или vld или vad
console.log( "Vlad".match(/v[la]d/gi) )
```
***

## Диапазоны

Пример с совмещением: 

```javascript
// Искать после символа x число от 0-9 или букву от A до F (можно наоборот) и также во втором символе 
console.log( "Kravich 0xAF".match(/x[0-9A-F][0-9A-F]/g) ) // Array [ "xAF" ]
console.log( "Kravich 0xB1".match(/x[0-9A-F][0-9A-F]/g) ) // Array [ "xB1" ]
console.log( "Kravich 0x13".match(/x[0-9A-F][0-9A-F]/g) ) // Array [ "x13" ]
```
***

## Исключающие диапазоны

* `[^kra]` - любой символ, кроме `kra`.
* `[^7-9]` - любой символ, за исключением чисел от `7` до `9`.
* `[^\s]` - любой непробельный символ (тоже самое, что и `\S`).


Пример с поиском любых символов, кроме латинских букв, цифр и пробелов: 

```javascript
// Array [ "@", "." ]
console.log( "kravich13@gmail.com".match(/[^\d\sA-Z]/gi) )
```
***

## Экранирование внутри [...]

Обычно, спец. символы нужно экранировать с помощью `\`, но `[]` скобки позволяют просто запихнуть в них спец. символы и они станут обычными символами.

Поддерживающие символы: 

* `. + ()` не нужно экранировать.
* `-` не нужно экранировать в начале или в конце (где оно не задаёт диапазон).
* `^` - нужно экранировать только в начале (где он означает исключение).
* Закрывающую квадратную скобку `]`, если нужен именно такой символ, экранировать нужно.

Поиск одного из заданных спец. символов в `[]`:

```javascript
// Array(6) [ "+", "(", ")", "-", ".", "^" ]
console.log( "Vlad + () - Kravich.^".match(/[-().^+]/g) ) 
```
***

# Квантификаторы + * ? {n}

Чтобы найти 5 чисел - достаточно ввести `/\d{5}/`:

```javascript
// Array [ "13000" ] - 5 цифр
console.log( "13000000$".match(/\d{5}/) )
```

Чтобы найти диапазон чисел - нужно вводить `/\d{5,9}/`:

```javascript
// Array [ "13000", "13000000" ]
console.log( "Сначала 13000$, потом 13000000$".match(/\d{5,9}/g) )
```

Верхнюю границу можно не указывать, для этого `/\d{5,}/`: 

```javascript
// Array [ "13000", "13000000" ] - верхняя граница бесконечна
console.log( "Сначала 13000$, потом 13000000$".match(/\d{5,}/g) )
```
**Также это всё применимо ко всем остальным символам.**

***

## Короткие обозначения

* `+` - означает один или более:

```javascript
// [ "38", "066", "130", "33", "13" ] 
console.log( "+38(066)-130-33-13".match(/\d+/g) )
```

* `?` - означает ноль или один: 

```javascript
// Array [ "color", "colour" ]
console.log( "Следует писать color или colour?".match(/colou?r/g) )
```

* `*` - означает ноль или более

```javascript
// Array(3) [ "100", "10", "1" ]
console.log( "100 10 1".match(/\d0*/g) )
```
***

# Ленивые квантификаторы

Ленивый квантификатор означает: повторять квантификатор наименьшее количество раз.

Сделать это можно с помощью знака `?` после квантификатора, т.е. будет `*?` или `+?` или даже `??` для `?`.

Обычно знак вопроса `?` сам по себе является квантификатором (ноль или один), но, если он добавлен после другого квантификатора (или даже после самого себя), он получает другое значение – он меняет режим совпадения с жадного на ленивый.

Пример: 

```javascript
console.log( "123 456".match(/\d+ \d+?/) ) // Array [ "123 4" ]
```

1. Шаблон `\d+` пытается найти столько цифр, сколько возможно (жадный режим), так что он находит `123` и останавливается, потому что следующим символом будет пробел `' '`.
2. Дальше в шаблоне пробел и в строке тоже, так что есть совпадение.
3. Затем идёт `\d+?`. Квантификатор находится в ленивом режиме, так что он находит одну цифру `4` и проверяет, есть ли совпадение для оставшегося шаблона с этого места.

    …Но в шаблоне `\d+?` больше ничего нет.

    Ленивый режим ничего не повторяет без необходимости. Шаблон закончился, заканчивается и поиск. Мы получаем `123 4`.
***

# Скобочные группы

Часть шаблона можно заключить в скобки `(...)` - это скобочная группа.

У такого выделения есть дфа эффекта: 
1. Позволяет поместить часть совпадения в отдельный массив.
2. Если установить квантификатор после скобок, то он будет применяться ко всему содержимому скобки, а не к одному символу.

### Пример: gogo

`()` скобки ищут `go`, после которого может быть ещё `go`: 

```javascript
// Array [ "Gogogo", "go" ]
console.log( "Gogogo now".match(/(go)+/i) )
```
***

## Содержимое скобок в match

Метод `str.match(regexp)`, если у регулярного выражения `regexp` нет флага `g`, ищет первое совпадение и возвращает его в виде массива:

1. На позиции `0` будет всё совпадение целиком.
2. На позиции `1` – содержимое первой скобочной группы.
3. На позиции `2` – содержимое второй скобочной группы.
4. …и так далее…


```javascript
let str = '<h1>Hello, world!</h1>'

// сначала записал тег в целом, а после - его содержимое в <>
let tag = str.match(/<(.*?)>/)

console.log( tag[0] ) // <h1>
console.log( tag[1] ) // h1
```
***

## Вложенные группы

Скобки могут быть вложенными.

К примеру при поиске тега нас может интересовать содержимое тега целиком, название тега и его атрибуты.

Для этого нужно заключить их в скобки в шаблоне: `\<(([a-z]+)\s*(^>)*)>\`.

```javascript
let str = '<p id="kra">' 

// найти <( (все буквы) разделенные пробелом (найти все символы) )>
let regexp = /<(([a-z]+)\s*([^>]*))>/
let result = str.match(regexp)

result 
// 0: "<p id=\"kra\">" - тег целиком
​// 1: "p id=\"kra\"" - его содержимое
​// 2: "p" - название тега
// 3: "id=\"kra\"" - его атрибуты
```
***

## Поиск всей совпадений с группами: matchAll

Для получения всех совпадений с множественными тегами используется метод `matchAll`, у него есть три отличия от `match`:
* Он возвращает не массив, а перебираемый объект.
* При поиске с флагом `g`, он возвращает каждое совпадение в виде массива со скобочными группами.
* Если совпадений нет, он возвращает не `null`, а просто пустой перебираемый объект.

```javascript
let results = '<h1> <h2>'.matchAll(/<(.*?)>/gi)

// results - не массив, а перебираемый объект
console.log(results) // [object RegExp String Iterator]

console.log(results[0]) // undefined

results = Array.from(results) // превращаем в массив

console.log(results[0]) // <h1>,h1 (первый тег)
console.log(results[1]) // <h2>,h2 (второй тег)
```
***

## Именованные группы

Для придания имени скобкам нужно добавить `?<name>` непосредственно после открытия скобки:

```javascript
let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/
let str = "1997-09-02"

let groups = str.match(dateRegexp).groups

console.log(groups.year) // 1997
console.log(groups.month) // 09
console.log(groups.day) // 02
```

Чтобы найти не только первую дату, используем флаг `g`.

Также нам понадобится `matchAll`, чтобы получить скобочные группы:

```javascript
let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g

let str = "2019-10-30 2020-01-01"

let results = str.matchAll(dateRegexp)

for(let result of results) {
  let {year, month, day} = result.groups

  console.log(`${day}.${month}.${year}`)
  // первый вывод: 30.10.2019
  // второй: 01.01.2020
}
```
***
# Юникодные свойства \p{...}

В регулярном выражении можно искать символ с заданным свойством, указав его в `\p{…}`. Для таких регулярных выражений обязательно использовать флаг `u`.

Вот основные категории символов и их подкатегории:

* Буквы `L`:
    * в нижнем регистре `Ll`,
    * модификаторы `Lm`,
    * заглавные буквы `Lt`,
    * в верхнем регистре `Lu`,
    * прочие `Lo`.
* Числа `N`:
    * десятичная цифра `Nd`,
    * цифры обозначаемые буквами (римские) `Nl`,
    * прочие `No`.
* Знаки пунктуации `P`:
    * соединители `Pc`,
    * тире `Pd`,
    * открывающие кавычки `Pi`,
    * закрывающие кавычки `Pf`,
    * открывающие скобки `Ps`,
    * закрывающие скобки `Pe`,
    * прочее `Po`.
* Отметки `M` (например, акценты):
    * двоеточия `Mc`,
    * вложения `Me`,
    * апострофы `Mn`.
* Символы `S`:
    * валюты `Sc`, модификаторы `Sk`, математические `Sm`, прочие `So`.
* Разделители `Z`:
    * линия `Zl`,
    * параграф `Zp`,
    * пробел `Zs`.
* Прочие `C`:
    * контрольные `Cc`,
    * форматирование `Cf`,
    * не назначенные `Cn`,
    * для приватного использования `Co`,
    * суррогаты `Cs`.

Так что, например, если нам нужны буквы в нижнем регистре, то можно написать `\p{Ll}`, знаки пунктуации: `\p{P}` и так далее.

### **Пример: валюта**

Символы, обозначающие валюты, такие как $, €, ¥ и другие, имеют свойство `\p{Currency_Symbol}`, короткая запись `\p{Sc}`.

```javascript
// поиск валюты, по цифрам, все совпадения, поддержка юникода
let regexp = /\p{Sc}\d/gu

let str = `Цены: $2, €1, ¥9`

console.log( str.match(regexp) ) // Array(3) [ "$2", "€1", "¥9" ]
```