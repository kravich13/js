# localStorage, sessionStorage

Объекты веб хранилища `localStorage` и `sessionStorage` позволяют хранить пары ключ/значение в браузере.

Данные, которые в них записаны, сохраняются после обновления страницы (в случае `sessionStorage`) и даже после перезагрузки браузера (в случае `localStorage`).

* В отличии от куки, объекты веб-хранищила не отправляются на сервер при каждом запросе.
* Сервер не может манипулировать объектами хранилища через HTTP-заголовки.
* Хранилище привязано к источнику (домен/протоколол/порт). Это значит, что разные протоколы или поддомены определяют разные объекты хранилища, и они не могут получить доступ к данным друг друга.

Объекты хранилища `localStorage` и `sessionStorage` имеют следующие методы:

* `setItem(key, value)` – сохранить пару ключ/значение.
* `getItem(key)` – получить данные по ключу `key`.
* `removeItem(key)` – удалить данные с ключом `key`.
* `clear()` – удалить всё.
* `key(index)` – получить ключ на заданной позиции.
* `length` – количество элементов в хранилище.

Интерфейс похож на `Map`, но также запоминается порядок элементов и можно получить доступ к элементу по индексу (почти как у массива) - `key(index)`.
***

## localStorage

Основные особенности `localStorage`:
* Этот объект один на все вкладки и окна в рамках источника (один и тот же домен/протокол/порт).
* Данные не имеют срока давности, по которому истекают и удаляются. Они сохраняются даже после перезагрузки браузера и даже ОС.

Пример взаимосвязи одного браузера с другим: 

```javascript
// Firefox
localStorage.setItem("user", "Vlad")

console.log(localStorage) 
// console.log(localStorage) // Storage { user: "Vlad", length: 1 }



// Ghrome
console.log(localStorage) 
// console.log(localStorage) // Storage { user: "Vlad", length: 1 }
```

Объект `localStorage` доступен во всех окнах из одного источника, поэтому, если установить данные в одном окне, а открыть их в другом браузере - изменения будут доступны.
***

## Доступ как к обычному объекту

Также можно получать/записывать/удалять данные как и обычный объект: 

```javascript
localStorage.test = 2
console.log(localStorage) // Storage { test: "2", length: 1 }

delete localStorage.test // Storage { length: 0 }
```

Такой подход не рекомендуется, потому что: 
1. Если ключ генерируется пользователем, то он может быть каким угодно, включая `length` или `toString` или другой встроенный метод `localStorage`. В этом случае `getItem/setItem` сработают нормально, а вот чтение/запись как свойства объекта не пройдут.
2. Когда мы модифицируем данные, то срабатывает событие `storage`. Но это событие не происходит при записи без `setItem`, как свойства объекта. 
***

## Перебор ключей

Объекты веб-хранилища нельзя перебрать в цикле как обычный объект, они не итерируемы.

Но можно пройтись по ним, как по обычным массивам:

```javascript
localStorage.setItem("user", "Vlad") 
localStorage.setItem("age", 22) 

for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i)
    
    console.log(`${key}: ${localStorage.getItem(key)}`)
    // user: Vlad, age : 22
}
```

Другой способ - использовать цикл, как по обычному объекту `for key in localStorage`.

Здесь перебираются ключи, но вместе с этим выводятся несколько встроенных полей, которые не нужны:

```javascript
for (let key in localStorage) console.log(key) 
// покажет встроенные методы типа setItem/getItem и т.д.
```

По этому нужно либо отфильтровать поля из прототипа проверкой `hasOwnProperty`, либо просто получить собственные ключи с помощью `Object.keys`, а затем вывести их при помощи цикла:

```javascript
localStorage.setItem("user", "Vlad") 
localStorage.setItem("age", 22) 

const keys = Object.keys(localStorage)

for (ley key in keys) {
    console.log( `${key}: ${localStorage.getItem(key)}` )
    // user: Vlad, age : 22
}
```

`Object.keys` возвращает только ключи, принадлежащие объекту, игнорируя прототип.
***

## Только строки

Ключ и значение должны быть только строками.

Если использовать любой друг тип, типа числа или объект, то он автоматически преобразуется в строку.

Для хранения объектов можно использовать `JSON`:

```javascript
sessionStorage.user = JSON.stringify({ name: "Vlad" })

const user = JSON.parse( sessionStorage.user )
console.log(user.name) // Vlad
```
***

## sessionStorage

у объекта `sessionStorage` свойства и методы такие же, но есть существенные ограничения:
* `sessionStorage` существует только в рамках одной вкладки браузера.
    * Другая вкладка с той же страницей будет иметь другое хранилище.
* Данные продолжают существовать после перезагрузки страницы, но не после закрытия/открытия вкладки.

Пример: 

```javascript
// Firefox, вкладка 1
sessionStorage.setItem("user", "Vlad")


// Firefox, вкладка 2
console.log(sessionStorage) // Storage { length: 0 }
```
***

## Ivent storage

Когда обновляются данные в `localStorage` или `sessionStorage`, генерируется событие `storage` со следующими свойствами:
* `key` – ключ, который обновился (`null`, если вызван `.clear()`).
* `oldValue` – старое значение (`null`, если ключ добавлен впервые).
* `newValue` – новое значение (`null`, если ключ был удалён).
* `url` – `url` документа, где произошло обновление.
* `storageArea` – объект `localStorage` или `sessionStorage`, где произошло обновление.

**Событие срабатывает на всех остальных объектах `window`, где доступно хранилище, кроме того окна, которое его вызывало.**

Есть два окна с одним и тем же сайтом, хранилище `localStorage` разделяется между ними.

Оба окна слушают `window.onstorage` и каждое из них будет реагировать на обновления, произошедшие в другом окне:

```javascript
// срабатывает при обновлениях, сделанных в том же хранилище из других документов
window.onstorage = event => {
  if (event.key != 'now') return;
  alert(event.key + ':' + event.newValue + " at " + event.url);
};

localStorage.setItem('now', Date.now());
```