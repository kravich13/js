# Препроцессор SCSS

## Создание и подключение 

Создаётся файл `index.html`, рядом создаётся файл `style.scss`. 

Далее, в терминале Code на Linux пишется команда `sass --watch style.scss style.css `, которая автоматически создаётся `style.css` и импортирует туда все селекторы из `scss` файла.


В `index.html` нужно подключить файл `style.css` строкой ` <link rel="stylesheet" href="style.css">`.

***

## Суть SCSS

`SCSS` позволяет писать код в файле `style.scss` на разных уровнях вложенности, сохранять цвета, данные и прочее в переменные и вписывать эти переменные по одному разу вместо копипаста нужных данных. 

Примеры ниже.

***

## Переменные

`SCSS` позволяет работать с переменными. В `CSS` они обозначаются двойным тире `--`, а в препроцессорах знаком доллара `$`.

```scss
$number: 1;
$color: #ff0000;
$text: "tproger forever.";
$text: "IT forever." !default;
$nothing: null;
```

Можно присваивать значения по умолчанию переменным, у которых ещё нет значения, добавив метку `!default` в конце значения. В таком случае, если переменной уже было присвоено значение, оно не изменится. Если же переменная пуста, ей будет присвоено новое указанное значение.

```scss
#container {
  content: $text;
}
```
***

## Вложенные правила

Стандартные вложенные CSS-элементы с использованием пробела: 

```css
#A {
  color: red;
}
#A #B {
  color: green;
}
#A #B #C p {
  color: blue;
}
```

Те же вложенные элементы с помощью SCSS: 

```scss
#A {
    color: red;
    #B {
        color: green;
        #C p {
            color: blue;
        }
    }
}
```

Такой код гораздо чище, красивее и понятнее. А что самое главное - в нём нет никаких повторений как в обычном `css`.

По факту, `scss` работает точно так же, как `html`: вложенностями. Причем `scss` повторяет структуру `html`.
***

## Ампресанд 

В `SCSS` используется директива `&`.

```scss
#p {
  color: black;
  a {
    font-weight: bold;
    &:hover {
      color: red;
    }
  }
}
```

С помощью символа `&` можно явно указать, где должен быть вставлен родительский селектор.
***

## Миксины (они же примеси)

Миксины объявляются директивой `@mixin`. После неё должно стоять имя миксина и параметры, а так же тело самой функции (миксин). Например, можно определить миксин `flexible()`, который далее будет включён, например, в класс `.centered-elements` следующим образом: 

```scss
// тоже самое, что function flexible () {}
@mixin flexible () {
    display: flex;
    justify-content: center;
    align-items: center;
  }
  
.centered-elements {
    @include flexible (); // вызов функции
    border: 1px solid gray;
  }
```
Теперь каждый раз после применения класса .centered-elements к `HTML`-элементу, последний будет преобразован во `Flexbox`.

Миксины так же могут содержать селекторы, в том числе со свойствами. А селекторы могут содержать ссылки на родительский элемент через ампресанд `&`.
***

## Примем работы с несколькими браузерами

Некоторые вещи в `CSS` весьма утомительно писать, особенно в `CSS3`, где плюс ко всему зачастую требуется использовать большое кол-во вендорных префиксов `-webkit-` или `-moz-`.

Миксины позволяют создавать группы деклараций `CSS`, которые придется несколько раз использовать на сайте. Хорошей практикой будет использование миксинов для вендорных префиксов. Например: 

```scss
@mixin border-radius ($radius) { // параметр так же пишется через $
    // Префиксы для:
    -webkit-border-radius: $radius;    // Chrome и Safari
       -moz-border-radius: $radius;    // Firefox
        -ms-border-radius: $radius;    // Internet Explorer
         -o-border-radius: $radius;    // Opera
            border-radius: $radius;    // Стандартный CSS
  }
// Пример использования миксина border-radius после его создания
.box { 
    @include border-radius(10px);  
    // вызов функции с соответствующим названием с передаваемым параметром 10px
}
```
*** 

## Арифметические операции

Как и в реальной жизни, мы не можем работать с числами, у которых несовместимы типы данных (например, сложение `px` и `em`).

### Cложение и вычитание

```scss
p {
    font-size: 10px + 2em; // ОШИБКА
    font-size: 10px + 6px; // 16px
    font-size: 10px + 2; // 12px
}
```

Вычитание: 

```scss
div {
    height: 12% - 2%; 
    margin: 4rem - 1; 
}
```
### Умножение

Выполняется точно так же, как в `CSS`, с помощью `calc(a*b)`, но без `calc` и круглых скобок. Кроме того, можно ещё отделять знак умножения пробелами от чисел: `13*3 == 13 * 3`.

<b>Исключение:</b> нельзя умножать пиксели между собой. Т.е. `10px * 10px != 100px`, а `10px * 10 == 100px`.

```scss
P {
    width: 10px * 10px; // ОШИБКА
    width: 10px * 10; // 100px
    width: 1px * 5 + 5px; // 10px
    width: 5 * (5px + 5px); // 50px
    width: 5px + (10px / 2) * 3; // 20px
}
```
### Деление

С делением чуть сложнее, ведь в стандартном `CSS` знак `/` зарезервирован для использования краткой формы записи свойств. 

```css
/* краткая форма записи свойств */
font: italic bold .8em/1.2 Arial, sans-serif;

/* стандартная форма записи свойств */
font-style: italic;
font-weight: bold;
font-size: .8em;
line-height: 1.2;
font-family: Arial, sans-serif;
```

Есть три помощника, которые намекнут на возможность деления: 

1. Значение (или любая его часть) хранится в переменной или возвращается функцией.
2. Значения заключены в круглые скобки.
3. Значение используется как часть другого арифметического вырежиня.

Пример: 

```scss
$var1: 20;
$var2: 4;

p {
    top: 16px / 24px; // отображается без изменений в стандартном CSS
    top: (20px / 5px);         // Производится деление (но только при использовании скобок)
    top: #{$var1} / #{$var2};  // Выводится как обычный CSS-код, деление не выполняется
    top: $var1 / $var2;        // Деление выполняется
    top: random(4) / 5;        // Деление выполняется (если использовать в паре с функцией)
    top: 2px / 4px + 3px;      // Деление выполняется, если добавлена ещё одно арифметическое действие
}
```

Результат компиляции в `CSS`: 

```css
p {
    top: 16px / 24px;
    top: 4;
    top: 20 / 4;
    top: 5;
    top: 0.6;
    top: 3.5px;
}
```

### Остаток

Остаток вычисляет остаток от операции деления. Ниже рассмотрим, как создать «зебру» для HTML-списка.

```scss
@mixin zebra() { // обычная функция
    @for $i from 1 through 7 { // обычный цикл
        @if ($i % 2 == 1) { // обычное условие с обычным тестом на чётность
            .stripe-#{$i} { // если цифра в классе нечётная - покрасим в чёрный
                background-color: black;
                color: white;
                // 1 3 5 7 будут чёрными
            }
        }
    }
}
* {
  @include zebra(); // вызов функции
  text-align: center;
}
```
Для создания образца надо записать несколько HTML-элементов.

```html
<div class="stripe-1">zebra</div>  
<div class="stripe-2">zebra</div>
<div class="stripe-3">zebra</div>
<div class="stripe-4">zebra</div>
<div class="stripe-5">zebra</div>
<div class="stripe-6">zebra</div>
<div class="stripe-7">zebra</div>
```
***

## Строки 
В `CSS` определено 2 типа строк: с кавычками и без. `SCSS` распознаёт то и другое. В итоге в `CSS` получится тот тип строк, который был использован в `SCSS`.

```scss
p {
    font: "50px" + Arial; // ОШИБКА
}
```

Можно складывать строки разных типов, если в них нет пробелов:

```scss
p:after {
    content: "Верните Линуса " + Торвальдса!; // ОШИБКА!
}
```

Строки, содержащие пробелы, должны быть отделены кавычками. Решение проблемы:

```scss
p:after {
    content: "Верните Линуса " + "Торвальдса!"; // обратите внимание на "Торвальдса!"
}
```

Пример сложения нескольких строк:

```scss
p:after {
    content: "Удел " + "человечества " + "—" + "итерация.";
}
```

Сложение строк и чисел:

```scss
p:after {
    content: "Рекурсия " + 2013 + " удел небожителей";
}
```